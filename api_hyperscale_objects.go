/*
Delphix DCT API

Delphix DCT API

API version: 3.17.0
Contact: support@delphix.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package delphix_dct_api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// HyperscaleObjectsAPIService HyperscaleObjectsAPI service
type HyperscaleObjectsAPIService service

type ApiCreateHyperscaleConnectorRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleConnectorCreateParameters *HyperscaleConnectorCreateParameters
}

func (r ApiCreateHyperscaleConnectorRequest) HyperscaleConnectorCreateParameters(hyperscaleConnectorCreateParameters HyperscaleConnectorCreateParameters) ApiCreateHyperscaleConnectorRequest {
	r.hyperscaleConnectorCreateParameters = &hyperscaleConnectorCreateParameters
	return r
}

func (r ApiCreateHyperscaleConnectorRequest) Execute() (*CreateHyperscaleConnectorResponse, *http.Response, error) {
	return r.ApiService.CreateHyperscaleConnectorExecute(r)
}

/*
CreateHyperscaleConnector Create a Hyperscale Connector.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateHyperscaleConnectorRequest
*/
func (a *HyperscaleObjectsAPIService) CreateHyperscaleConnector(ctx context.Context) ApiCreateHyperscaleConnectorRequest {
	return ApiCreateHyperscaleConnectorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateHyperscaleConnectorResponse
func (a *HyperscaleObjectsAPIService) CreateHyperscaleConnectorExecute(r ApiCreateHyperscaleConnectorRequest) (*CreateHyperscaleConnectorResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateHyperscaleConnectorResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.CreateHyperscaleConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-connectors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hyperscaleConnectorCreateParameters == nil {
		return localVarReturnValue, nil, reportError("hyperscaleConnectorCreateParameters is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hyperscaleConnectorCreateParameters
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateHyperscaleConnectorTagsRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleConnectorId string
	tagsRequest *TagsRequest
}

// Tag information for a Hyperscale Connector.
func (r ApiCreateHyperscaleConnectorTagsRequest) TagsRequest(tagsRequest TagsRequest) ApiCreateHyperscaleConnectorTagsRequest {
	r.tagsRequest = &tagsRequest
	return r
}

func (r ApiCreateHyperscaleConnectorTagsRequest) Execute() (*TagsResponse, *http.Response, error) {
	return r.ApiService.CreateHyperscaleConnectorTagsExecute(r)
}

/*
CreateHyperscaleConnectorTags Create tags for a Hyperscale Connector.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleConnectorId The ID of the Hyperscale Connector.
 @return ApiCreateHyperscaleConnectorTagsRequest
*/
func (a *HyperscaleObjectsAPIService) CreateHyperscaleConnectorTags(ctx context.Context, hyperscaleConnectorId string) ApiCreateHyperscaleConnectorTagsRequest {
	return ApiCreateHyperscaleConnectorTagsRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleConnectorId: hyperscaleConnectorId,
	}
}

// Execute executes the request
//  @return TagsResponse
func (a *HyperscaleObjectsAPIService) CreateHyperscaleConnectorTagsExecute(r ApiCreateHyperscaleConnectorTagsRequest) (*TagsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.CreateHyperscaleConnectorTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-connectors/{hyperscaleConnectorId}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleConnectorId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleConnectorId, "hyperscaleConnectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleConnectorId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleConnectorId must have at least 1 elements")
	}
	if r.tagsRequest == nil {
		return localVarReturnValue, nil, reportError("tagsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateHyperscaleDatasetTagsRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleDatasetId string
	tagsRequest *TagsRequest
}

// Tag information for a Hyperscale Dataset.
func (r ApiCreateHyperscaleDatasetTagsRequest) TagsRequest(tagsRequest TagsRequest) ApiCreateHyperscaleDatasetTagsRequest {
	r.tagsRequest = &tagsRequest
	return r
}

func (r ApiCreateHyperscaleDatasetTagsRequest) Execute() (*TagsResponse, *http.Response, error) {
	return r.ApiService.CreateHyperscaleDatasetTagsExecute(r)
}

/*
CreateHyperscaleDatasetTags Create tags for a Hyperscale Dataset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleDatasetId The ID of the Hyperscale Dataset.
 @return ApiCreateHyperscaleDatasetTagsRequest
*/
func (a *HyperscaleObjectsAPIService) CreateHyperscaleDatasetTags(ctx context.Context, hyperscaleDatasetId string) ApiCreateHyperscaleDatasetTagsRequest {
	return ApiCreateHyperscaleDatasetTagsRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleDatasetId: hyperscaleDatasetId,
	}
}

// Execute executes the request
//  @return TagsResponse
func (a *HyperscaleObjectsAPIService) CreateHyperscaleDatasetTagsExecute(r ApiCreateHyperscaleDatasetTagsRequest) (*TagsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.CreateHyperscaleDatasetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-datasets/{hyperscaleDatasetId}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleDatasetId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleDatasetId, "hyperscaleDatasetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleDatasetId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleDatasetId must have at least 1 elements")
	}
	if r.tagsRequest == nil {
		return localVarReturnValue, nil, reportError("tagsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateHyperscaleMountPointRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleMountPoint *HyperscaleMountPoint
}

// Request to create a Hyperscale Mount Point.
func (r ApiCreateHyperscaleMountPointRequest) HyperscaleMountPoint(hyperscaleMountPoint HyperscaleMountPoint) ApiCreateHyperscaleMountPointRequest {
	r.hyperscaleMountPoint = &hyperscaleMountPoint
	return r
}

func (r ApiCreateHyperscaleMountPointRequest) Execute() (*CreateHyperscaleMountPointResponse, *http.Response, error) {
	return r.ApiService.CreateHyperscaleMountPointExecute(r)
}

/*
CreateHyperscaleMountPoint Create a Hyperscale Mount Point

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateHyperscaleMountPointRequest
*/
func (a *HyperscaleObjectsAPIService) CreateHyperscaleMountPoint(ctx context.Context) ApiCreateHyperscaleMountPointRequest {
	return ApiCreateHyperscaleMountPointRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateHyperscaleMountPointResponse
func (a *HyperscaleObjectsAPIService) CreateHyperscaleMountPointExecute(r ApiCreateHyperscaleMountPointRequest) (*CreateHyperscaleMountPointResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateHyperscaleMountPointResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.CreateHyperscaleMountPoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-mount-points"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hyperscaleMountPoint == nil {
		return localVarReturnValue, nil, reportError("hyperscaleMountPoint is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hyperscaleMountPoint
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteHyperscaleConnectorRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleConnectorId string
}

func (r ApiDeleteHyperscaleConnectorRequest) Execute() (*DeleteHyperscaleConnectorResponse, *http.Response, error) {
	return r.ApiService.DeleteHyperscaleConnectorExecute(r)
}

/*
DeleteHyperscaleConnector Delete a Hyperscale Connector.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleConnectorId The ID of the Hyperscale Connector.
 @return ApiDeleteHyperscaleConnectorRequest
*/
func (a *HyperscaleObjectsAPIService) DeleteHyperscaleConnector(ctx context.Context, hyperscaleConnectorId string) ApiDeleteHyperscaleConnectorRequest {
	return ApiDeleteHyperscaleConnectorRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleConnectorId: hyperscaleConnectorId,
	}
}

// Execute executes the request
//  @return DeleteHyperscaleConnectorResponse
func (a *HyperscaleObjectsAPIService) DeleteHyperscaleConnectorExecute(r ApiDeleteHyperscaleConnectorRequest) (*DeleteHyperscaleConnectorResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteHyperscaleConnectorResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.DeleteHyperscaleConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-connectors/{hyperscaleConnectorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleConnectorId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleConnectorId, "hyperscaleConnectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleConnectorId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleConnectorId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteHyperscaleConnectorTagsRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleConnectorId string
	deleteTag *DeleteTag
}

// The parameters to delete tags
func (r ApiDeleteHyperscaleConnectorTagsRequest) DeleteTag(deleteTag DeleteTag) ApiDeleteHyperscaleConnectorTagsRequest {
	r.deleteTag = &deleteTag
	return r
}

func (r ApiDeleteHyperscaleConnectorTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteHyperscaleConnectorTagsExecute(r)
}

/*
DeleteHyperscaleConnectorTags Delete tags for a Hyperscale Connector.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleConnectorId The ID of the Hyperscale Connector.
 @return ApiDeleteHyperscaleConnectorTagsRequest
*/
func (a *HyperscaleObjectsAPIService) DeleteHyperscaleConnectorTags(ctx context.Context, hyperscaleConnectorId string) ApiDeleteHyperscaleConnectorTagsRequest {
	return ApiDeleteHyperscaleConnectorTagsRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleConnectorId: hyperscaleConnectorId,
	}
}

// Execute executes the request
func (a *HyperscaleObjectsAPIService) DeleteHyperscaleConnectorTagsExecute(r ApiDeleteHyperscaleConnectorTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.DeleteHyperscaleConnectorTags")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-connectors/{hyperscaleConnectorId}/tags/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleConnectorId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleConnectorId, "hyperscaleConnectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleConnectorId) < 1 {
		return nil, reportError("hyperscaleConnectorId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteTag
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteHyperscaleDatasetTagsRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleDatasetId string
	deleteTag *DeleteTag
}

// The parameters to delete tags
func (r ApiDeleteHyperscaleDatasetTagsRequest) DeleteTag(deleteTag DeleteTag) ApiDeleteHyperscaleDatasetTagsRequest {
	r.deleteTag = &deleteTag
	return r
}

func (r ApiDeleteHyperscaleDatasetTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteHyperscaleDatasetTagsExecute(r)
}

/*
DeleteHyperscaleDatasetTags Delete tags for a Hyperscale Dataset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleDatasetId The ID of the Hyperscale Dataset.
 @return ApiDeleteHyperscaleDatasetTagsRequest
*/
func (a *HyperscaleObjectsAPIService) DeleteHyperscaleDatasetTags(ctx context.Context, hyperscaleDatasetId string) ApiDeleteHyperscaleDatasetTagsRequest {
	return ApiDeleteHyperscaleDatasetTagsRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleDatasetId: hyperscaleDatasetId,
	}
}

// Execute executes the request
func (a *HyperscaleObjectsAPIService) DeleteHyperscaleDatasetTagsExecute(r ApiDeleteHyperscaleDatasetTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.DeleteHyperscaleDatasetTags")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-datasets/{hyperscaleDatasetId}/tags/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleDatasetId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleDatasetId, "hyperscaleDatasetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleDatasetId) < 1 {
		return nil, reportError("hyperscaleDatasetId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteTag
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteHyperscaleMountPointRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleMountPointId string
}

func (r ApiDeleteHyperscaleMountPointRequest) Execute() (*DeleteHyperscaleMountPointResponse, *http.Response, error) {
	return r.ApiService.DeleteHyperscaleMountPointExecute(r)
}

/*
DeleteHyperscaleMountPoint Delete a Hyperscale Mount Point.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleMountPointId The ID of the Hyperscale Mount Point.
 @return ApiDeleteHyperscaleMountPointRequest
*/
func (a *HyperscaleObjectsAPIService) DeleteHyperscaleMountPoint(ctx context.Context, hyperscaleMountPointId string) ApiDeleteHyperscaleMountPointRequest {
	return ApiDeleteHyperscaleMountPointRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleMountPointId: hyperscaleMountPointId,
	}
}

// Execute executes the request
//  @return DeleteHyperscaleMountPointResponse
func (a *HyperscaleObjectsAPIService) DeleteHyperscaleMountPointExecute(r ApiDeleteHyperscaleMountPointRequest) (*DeleteHyperscaleMountPointResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteHyperscaleMountPointResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.DeleteHyperscaleMountPoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-mount-points/{hyperscaleMountPointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleMountPointId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleMountPointId, "hyperscaleMountPointId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleMountPointId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleMountPointId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHyperscaleConnectorByIdRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleConnectorId string
}

func (r ApiGetHyperscaleConnectorByIdRequest) Execute() (*HyperscaleConnector, *http.Response, error) {
	return r.ApiService.GetHyperscaleConnectorByIdExecute(r)
}

/*
GetHyperscaleConnectorById Get a Hyperscale Connector.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleConnectorId The ID of the Hyperscale Connector.
 @return ApiGetHyperscaleConnectorByIdRequest
*/
func (a *HyperscaleObjectsAPIService) GetHyperscaleConnectorById(ctx context.Context, hyperscaleConnectorId string) ApiGetHyperscaleConnectorByIdRequest {
	return ApiGetHyperscaleConnectorByIdRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleConnectorId: hyperscaleConnectorId,
	}
}

// Execute executes the request
//  @return HyperscaleConnector
func (a *HyperscaleObjectsAPIService) GetHyperscaleConnectorByIdExecute(r ApiGetHyperscaleConnectorByIdRequest) (*HyperscaleConnector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HyperscaleConnector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.GetHyperscaleConnectorById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-connectors/{hyperscaleConnectorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleConnectorId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleConnectorId, "hyperscaleConnectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleConnectorId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleConnectorId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHyperscaleConnectorTagsRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleConnectorId string
}

func (r ApiGetHyperscaleConnectorTagsRequest) Execute() (*TagsResponse, *http.Response, error) {
	return r.ApiService.GetHyperscaleConnectorTagsExecute(r)
}

/*
GetHyperscaleConnectorTags Get tags for a Hyperscale Connector.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleConnectorId The ID of the Hyperscale Connector.
 @return ApiGetHyperscaleConnectorTagsRequest
*/
func (a *HyperscaleObjectsAPIService) GetHyperscaleConnectorTags(ctx context.Context, hyperscaleConnectorId string) ApiGetHyperscaleConnectorTagsRequest {
	return ApiGetHyperscaleConnectorTagsRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleConnectorId: hyperscaleConnectorId,
	}
}

// Execute executes the request
//  @return TagsResponse
func (a *HyperscaleObjectsAPIService) GetHyperscaleConnectorTagsExecute(r ApiGetHyperscaleConnectorTagsRequest) (*TagsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.GetHyperscaleConnectorTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-connectors/{hyperscaleConnectorId}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleConnectorId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleConnectorId, "hyperscaleConnectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleConnectorId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleConnectorId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHyperscaleConnectorsRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	limit *int32
	cursor *string
	sort *string
}

// Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100.
func (r ApiGetHyperscaleConnectorsRequest) Limit(limit int32) ApiGetHyperscaleConnectorsRequest {
	r.limit = &limit
	return r
}

// Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints.
func (r ApiGetHyperscaleConnectorsRequest) Cursor(cursor string) ApiGetHyperscaleConnectorsRequest {
	r.cursor = &cursor
	return r
}

// The field to sort results by. A property name with a prepended &#39;-&#39; signifies descending order.
func (r ApiGetHyperscaleConnectorsRequest) Sort(sort string) ApiGetHyperscaleConnectorsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetHyperscaleConnectorsRequest) Execute() (*ListHyperscaleConnectorsResponse, *http.Response, error) {
	return r.ApiService.GetHyperscaleConnectorsExecute(r)
}

/*
GetHyperscaleConnectors Returns a list of Hyperscale Connectors.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHyperscaleConnectorsRequest
*/
func (a *HyperscaleObjectsAPIService) GetHyperscaleConnectors(ctx context.Context) ApiGetHyperscaleConnectorsRequest {
	return ApiGetHyperscaleConnectorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListHyperscaleConnectorsResponse
func (a *HyperscaleObjectsAPIService) GetHyperscaleConnectorsExecute(r ApiGetHyperscaleConnectorsRequest) (*ListHyperscaleConnectorsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListHyperscaleConnectorsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.GetHyperscaleConnectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-connectors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHyperscaleDatasetByIdRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleDatasetId string
}

func (r ApiGetHyperscaleDatasetByIdRequest) Execute() (*HyperscaleDataset, *http.Response, error) {
	return r.ApiService.GetHyperscaleDatasetByIdExecute(r)
}

/*
GetHyperscaleDatasetById Get a Hyperscale Dataset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleDatasetId The ID of the Hyperscale Dataset.
 @return ApiGetHyperscaleDatasetByIdRequest
*/
func (a *HyperscaleObjectsAPIService) GetHyperscaleDatasetById(ctx context.Context, hyperscaleDatasetId string) ApiGetHyperscaleDatasetByIdRequest {
	return ApiGetHyperscaleDatasetByIdRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleDatasetId: hyperscaleDatasetId,
	}
}

// Execute executes the request
//  @return HyperscaleDataset
func (a *HyperscaleObjectsAPIService) GetHyperscaleDatasetByIdExecute(r ApiGetHyperscaleDatasetByIdRequest) (*HyperscaleDataset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HyperscaleDataset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.GetHyperscaleDatasetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-datasets/{hyperscaleDatasetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleDatasetId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleDatasetId, "hyperscaleDatasetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleDatasetId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleDatasetId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHyperscaleDatasetTableOrFileByIdRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleDatasetId string
	hyperscaleDatasetTableOrFileId string
}

func (r ApiGetHyperscaleDatasetTableOrFileByIdRequest) Execute() (*HyperscaleDatasetTableOrFile, *http.Response, error) {
	return r.ApiService.GetHyperscaleDatasetTableOrFileByIdExecute(r)
}

/*
GetHyperscaleDatasetTableOrFileById Get a Hyperscale Dataset table or file by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleDatasetId The ID of the Hyperscale Dataset.
 @param hyperscaleDatasetTableOrFileId The ID of the Hyperscale Dataset table or file.
 @return ApiGetHyperscaleDatasetTableOrFileByIdRequest
*/
func (a *HyperscaleObjectsAPIService) GetHyperscaleDatasetTableOrFileById(ctx context.Context, hyperscaleDatasetId string, hyperscaleDatasetTableOrFileId string) ApiGetHyperscaleDatasetTableOrFileByIdRequest {
	return ApiGetHyperscaleDatasetTableOrFileByIdRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleDatasetId: hyperscaleDatasetId,
		hyperscaleDatasetTableOrFileId: hyperscaleDatasetTableOrFileId,
	}
}

// Execute executes the request
//  @return HyperscaleDatasetTableOrFile
func (a *HyperscaleObjectsAPIService) GetHyperscaleDatasetTableOrFileByIdExecute(r ApiGetHyperscaleDatasetTableOrFileByIdRequest) (*HyperscaleDatasetTableOrFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HyperscaleDatasetTableOrFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.GetHyperscaleDatasetTableOrFileById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-datasets/{hyperscaleDatasetId}/tables-or-files/{hyperscaleDatasetTableOrFileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleDatasetId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleDatasetId, "hyperscaleDatasetId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleDatasetTableOrFileId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleDatasetTableOrFileId, "hyperscaleDatasetTableOrFileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleDatasetId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleDatasetId must have at least 1 elements")
	}
	if strlen(r.hyperscaleDatasetTableOrFileId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleDatasetTableOrFileId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHyperscaleDatasetTablesOrFilesRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleDatasetId string
	limit *int32
	cursor *string
	sort *string
}

// Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100.
func (r ApiGetHyperscaleDatasetTablesOrFilesRequest) Limit(limit int32) ApiGetHyperscaleDatasetTablesOrFilesRequest {
	r.limit = &limit
	return r
}

// Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints.
func (r ApiGetHyperscaleDatasetTablesOrFilesRequest) Cursor(cursor string) ApiGetHyperscaleDatasetTablesOrFilesRequest {
	r.cursor = &cursor
	return r
}

// The field to sort results by. A property name with a prepended &#39;-&#39; signifies descending order.
func (r ApiGetHyperscaleDatasetTablesOrFilesRequest) Sort(sort string) ApiGetHyperscaleDatasetTablesOrFilesRequest {
	r.sort = &sort
	return r
}

func (r ApiGetHyperscaleDatasetTablesOrFilesRequest) Execute() (*ListHyperscaleDatasetTablesOrFilesResponse, *http.Response, error) {
	return r.ApiService.GetHyperscaleDatasetTablesOrFilesExecute(r)
}

/*
GetHyperscaleDatasetTablesOrFiles Get the tables or files of a hyperscale dataset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleDatasetId The ID of the Hyperscale Dataset.
 @return ApiGetHyperscaleDatasetTablesOrFilesRequest
*/
func (a *HyperscaleObjectsAPIService) GetHyperscaleDatasetTablesOrFiles(ctx context.Context, hyperscaleDatasetId string) ApiGetHyperscaleDatasetTablesOrFilesRequest {
	return ApiGetHyperscaleDatasetTablesOrFilesRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleDatasetId: hyperscaleDatasetId,
	}
}

// Execute executes the request
//  @return ListHyperscaleDatasetTablesOrFilesResponse
func (a *HyperscaleObjectsAPIService) GetHyperscaleDatasetTablesOrFilesExecute(r ApiGetHyperscaleDatasetTablesOrFilesRequest) (*ListHyperscaleDatasetTablesOrFilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListHyperscaleDatasetTablesOrFilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.GetHyperscaleDatasetTablesOrFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-datasets/{hyperscaleDatasetId}/tables-or-files"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleDatasetId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleDatasetId, "hyperscaleDatasetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleDatasetId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleDatasetId must have at least 1 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHyperscaleDatasetTagsRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleDatasetId string
}

func (r ApiGetHyperscaleDatasetTagsRequest) Execute() (*TagsResponse, *http.Response, error) {
	return r.ApiService.GetHyperscaleDatasetTagsExecute(r)
}

/*
GetHyperscaleDatasetTags Get tags for a Hyperscale Dataset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleDatasetId The ID of the Hyperscale Dataset.
 @return ApiGetHyperscaleDatasetTagsRequest
*/
func (a *HyperscaleObjectsAPIService) GetHyperscaleDatasetTags(ctx context.Context, hyperscaleDatasetId string) ApiGetHyperscaleDatasetTagsRequest {
	return ApiGetHyperscaleDatasetTagsRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleDatasetId: hyperscaleDatasetId,
	}
}

// Execute executes the request
//  @return TagsResponse
func (a *HyperscaleObjectsAPIService) GetHyperscaleDatasetTagsExecute(r ApiGetHyperscaleDatasetTagsRequest) (*TagsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.GetHyperscaleDatasetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-datasets/{hyperscaleDatasetId}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleDatasetId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleDatasetId, "hyperscaleDatasetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleDatasetId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleDatasetId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHyperscaleDatasetsRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	limit *int32
	cursor *string
	sort *string
}

// Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100.
func (r ApiGetHyperscaleDatasetsRequest) Limit(limit int32) ApiGetHyperscaleDatasetsRequest {
	r.limit = &limit
	return r
}

// Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints.
func (r ApiGetHyperscaleDatasetsRequest) Cursor(cursor string) ApiGetHyperscaleDatasetsRequest {
	r.cursor = &cursor
	return r
}

// The field to sort results by. A property name with a prepended &#39;-&#39; signifies descending order.
func (r ApiGetHyperscaleDatasetsRequest) Sort(sort string) ApiGetHyperscaleDatasetsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetHyperscaleDatasetsRequest) Execute() (*ListHyperscaleDatasetsResponse, *http.Response, error) {
	return r.ApiService.GetHyperscaleDatasetsExecute(r)
}

/*
GetHyperscaleDatasets Returns a list of Hyperscale Datasets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHyperscaleDatasetsRequest
*/
func (a *HyperscaleObjectsAPIService) GetHyperscaleDatasets(ctx context.Context) ApiGetHyperscaleDatasetsRequest {
	return ApiGetHyperscaleDatasetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListHyperscaleDatasetsResponse
func (a *HyperscaleObjectsAPIService) GetHyperscaleDatasetsExecute(r ApiGetHyperscaleDatasetsRequest) (*ListHyperscaleDatasetsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListHyperscaleDatasetsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.GetHyperscaleDatasets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-datasets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHyperscaleMountPointByIdRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleMountPointId string
}

func (r ApiGetHyperscaleMountPointByIdRequest) Execute() (*HyperscaleMountPoint, *http.Response, error) {
	return r.ApiService.GetHyperscaleMountPointByIdExecute(r)
}

/*
GetHyperscaleMountPointById Get a Hyperscale Mount Points.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleMountPointId The ID of the Hyperscale Mount Point.
 @return ApiGetHyperscaleMountPointByIdRequest
*/
func (a *HyperscaleObjectsAPIService) GetHyperscaleMountPointById(ctx context.Context, hyperscaleMountPointId string) ApiGetHyperscaleMountPointByIdRequest {
	return ApiGetHyperscaleMountPointByIdRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleMountPointId: hyperscaleMountPointId,
	}
}

// Execute executes the request
//  @return HyperscaleMountPoint
func (a *HyperscaleObjectsAPIService) GetHyperscaleMountPointByIdExecute(r ApiGetHyperscaleMountPointByIdRequest) (*HyperscaleMountPoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HyperscaleMountPoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.GetHyperscaleMountPointById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-mount-points/{hyperscaleMountPointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleMountPointId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleMountPointId, "hyperscaleMountPointId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleMountPointId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleMountPointId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHyperscaleMountPointsRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	limit *int32
	cursor *string
	sort *string
}

// Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100.
func (r ApiGetHyperscaleMountPointsRequest) Limit(limit int32) ApiGetHyperscaleMountPointsRequest {
	r.limit = &limit
	return r
}

// Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints.
func (r ApiGetHyperscaleMountPointsRequest) Cursor(cursor string) ApiGetHyperscaleMountPointsRequest {
	r.cursor = &cursor
	return r
}

// The field to sort results by. A property name with a prepended &#39;-&#39; signifies descending order.
func (r ApiGetHyperscaleMountPointsRequest) Sort(sort string) ApiGetHyperscaleMountPointsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetHyperscaleMountPointsRequest) Execute() (*ListHyperscaleMountPointsResponse, *http.Response, error) {
	return r.ApiService.GetHyperscaleMountPointsExecute(r)
}

/*
GetHyperscaleMountPoints Returns a list of Hyperscale Mount Points.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHyperscaleMountPointsRequest
*/
func (a *HyperscaleObjectsAPIService) GetHyperscaleMountPoints(ctx context.Context) ApiGetHyperscaleMountPointsRequest {
	return ApiGetHyperscaleMountPointsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListHyperscaleMountPointsResponse
func (a *HyperscaleObjectsAPIService) GetHyperscaleMountPointsExecute(r ApiGetHyperscaleMountPointsRequest) (*ListHyperscaleMountPointsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListHyperscaleMountPointsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.GetHyperscaleMountPoints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-mount-points"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchHyperscaleConnectorsRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	limit *int32
	cursor *string
	sort *string
	searchBody *SearchBody
}

// Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100.
func (r ApiSearchHyperscaleConnectorsRequest) Limit(limit int32) ApiSearchHyperscaleConnectorsRequest {
	r.limit = &limit
	return r
}

// Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints.
func (r ApiSearchHyperscaleConnectorsRequest) Cursor(cursor string) ApiSearchHyperscaleConnectorsRequest {
	r.cursor = &cursor
	return r
}

// The field to sort results by. A property name with a prepended &#39;-&#39; signifies descending order.
func (r ApiSearchHyperscaleConnectorsRequest) Sort(sort string) ApiSearchHyperscaleConnectorsRequest {
	r.sort = &sort
	return r
}

// A request body containing a filter expression. This enables searching for items matching arbitrarily complex conditions. The list of attributes which can be used in filter expressions is available in the x-filterable vendor extension.  # Filter Expression Overview **Note: All keywords are case-insensitive**  ## Comparison Operators | Operator | Description | Example | | --- | --- | --- | | CONTAINS | Substring or membership testing for string and list attributes respectively. | field3 CONTAINS &#39;foobar&#39;, field4 CONTAINS TRUE  | | IN | Tests if field is a member of a list literal. List can contain a maximum of 100 values | field2 IN [&#39;Goku&#39;, &#39;Vegeta&#39;] | | GE | Tests if a field is greater than or equal to a literal value | field1 GE 1.2e-2 | | GT | Tests if a field is greater than a literal value | field1 GT 1.2e-2 | | LE | Tests if a field is less than or equal to a literal value | field1 LE 9000 | | LT | Tests if a field is less than a literal value | field1 LT 9.02 | | NE | Tests if a field is not equal to a literal value | field1 NE 42 | | EQ | Tests if a field is equal to a literal value | field1 EQ 42 |  ## Search Operator The SEARCH operator filters for items which have any filterable attribute that contains the input string as a substring, comparison is done case-insensitively. This is not restricted to attributes with string values. Specifically &#x60;SEARCH &#39;12&#39;&#x60; would match an item with an attribute with an integer value of &#x60;123&#x60;.  ## Logical Operators Ordered by precedence. | Operator | Description | Example | | --- | --- | --- | | NOT | Logical NOT (Right associative) | NOT field1 LE 9000 | | AND | Logical AND (Left Associative) | field1 GT 9000 AND field2 EQ &#39;Goku&#39; | | OR | Logical OR (Left Associative) | field1 GT 9000 OR field2 EQ &#39;Goku&#39; |  ## Grouping Parenthesis &#x60;()&#x60; can be used to override operator precedence.  For example: NOT (field1 LT 1234 AND field2 CONTAINS &#39;foo&#39;)  ## Literal Values | Literal      | Description | Examples | | --- | --- | --- | | Nil | Represents the absence of a value | nil, Nil, nIl, NIL | | Boolean | true/false boolean | true, false, True, False, TRUE, FALSE | | Number | Signed integer and floating point numbers. Also supports scientific notation. | 0, 1, -1, 1.2, 0.35, 1.2e-2, -1.2e+2 | | String | Single or double quoted | \&quot;foo\&quot;, \&quot;bar\&quot;, \&quot;foo bar\&quot;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo bar&#39; | | Datetime | Formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) | 2018-04-27T18:39:26.397237+00:00 | | List | Comma-separated literals wrapped in square brackets | [0], [0, 1], [&#39;foo&#39;, \&quot;bar\&quot;] |  ## Limitations - A maximum of 8 unique identifiers may be used inside a filter expression. 
func (r ApiSearchHyperscaleConnectorsRequest) SearchBody(searchBody SearchBody) ApiSearchHyperscaleConnectorsRequest {
	r.searchBody = &searchBody
	return r
}

func (r ApiSearchHyperscaleConnectorsRequest) Execute() (*SearchHyperscaleConnectorsResponse, *http.Response, error) {
	return r.ApiService.SearchHyperscaleConnectorsExecute(r)
}

/*
SearchHyperscaleConnectors Search for Hyperscale Connectors.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchHyperscaleConnectorsRequest
*/
func (a *HyperscaleObjectsAPIService) SearchHyperscaleConnectors(ctx context.Context) ApiSearchHyperscaleConnectorsRequest {
	return ApiSearchHyperscaleConnectorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchHyperscaleConnectorsResponse
func (a *HyperscaleObjectsAPIService) SearchHyperscaleConnectorsExecute(r ApiSearchHyperscaleConnectorsRequest) (*SearchHyperscaleConnectorsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchHyperscaleConnectorsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.SearchHyperscaleConnectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-connectors/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.searchBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchHyperscaleDatasetTablesOrFilesRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleDatasetId string
	limit *int32
	cursor *string
	sort *string
	searchBody *SearchBody
}

// Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100.
func (r ApiSearchHyperscaleDatasetTablesOrFilesRequest) Limit(limit int32) ApiSearchHyperscaleDatasetTablesOrFilesRequest {
	r.limit = &limit
	return r
}

// Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints.
func (r ApiSearchHyperscaleDatasetTablesOrFilesRequest) Cursor(cursor string) ApiSearchHyperscaleDatasetTablesOrFilesRequest {
	r.cursor = &cursor
	return r
}

// The field to sort results by. A property name with a prepended &#39;-&#39; signifies descending order.
func (r ApiSearchHyperscaleDatasetTablesOrFilesRequest) Sort(sort string) ApiSearchHyperscaleDatasetTablesOrFilesRequest {
	r.sort = &sort
	return r
}

// A request body containing a filter expression. This enables searching for items matching arbitrarily complex conditions. The list of attributes which can be used in filter expressions is available in the x-filterable vendor extension.  # Filter Expression Overview **Note: All keywords are case-insensitive**  ## Comparison Operators | Operator | Description | Example | | --- | --- | --- | | CONTAINS | Substring or membership testing for string and list attributes respectively. | field3 CONTAINS &#39;foobar&#39;, field4 CONTAINS TRUE  | | IN | Tests if field is a member of a list literal. List can contain a maximum of 100 values | field2 IN [&#39;Goku&#39;, &#39;Vegeta&#39;] | | GE | Tests if a field is greater than or equal to a literal value | field1 GE 1.2e-2 | | GT | Tests if a field is greater than a literal value | field1 GT 1.2e-2 | | LE | Tests if a field is less than or equal to a literal value | field1 LE 9000 | | LT | Tests if a field is less than a literal value | field1 LT 9.02 | | NE | Tests if a field is not equal to a literal value | field1 NE 42 | | EQ | Tests if a field is equal to a literal value | field1 EQ 42 |  ## Search Operator The SEARCH operator filters for items which have any filterable attribute that contains the input string as a substring, comparison is done case-insensitively. This is not restricted to attributes with string values. Specifically &#x60;SEARCH &#39;12&#39;&#x60; would match an item with an attribute with an integer value of &#x60;123&#x60;.  ## Logical Operators Ordered by precedence. | Operator | Description | Example | | --- | --- | --- | | NOT | Logical NOT (Right associative) | NOT field1 LE 9000 | | AND | Logical AND (Left Associative) | field1 GT 9000 AND field2 EQ &#39;Goku&#39; | | OR | Logical OR (Left Associative) | field1 GT 9000 OR field2 EQ &#39;Goku&#39; |  ## Grouping Parenthesis &#x60;()&#x60; can be used to override operator precedence.  For example: NOT (field1 LT 1234 AND field2 CONTAINS &#39;foo&#39;)  ## Literal Values | Literal      | Description | Examples | | --- | --- | --- | | Nil | Represents the absence of a value | nil, Nil, nIl, NIL | | Boolean | true/false boolean | true, false, True, False, TRUE, FALSE | | Number | Signed integer and floating point numbers. Also supports scientific notation. | 0, 1, -1, 1.2, 0.35, 1.2e-2, -1.2e+2 | | String | Single or double quoted | \&quot;foo\&quot;, \&quot;bar\&quot;, \&quot;foo bar\&quot;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo bar&#39; | | Datetime | Formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) | 2018-04-27T18:39:26.397237+00:00 | | List | Comma-separated literals wrapped in square brackets | [0], [0, 1], [&#39;foo&#39;, \&quot;bar\&quot;] |  ## Limitations - A maximum of 8 unique identifiers may be used inside a filter expression. 
func (r ApiSearchHyperscaleDatasetTablesOrFilesRequest) SearchBody(searchBody SearchBody) ApiSearchHyperscaleDatasetTablesOrFilesRequest {
	r.searchBody = &searchBody
	return r
}

func (r ApiSearchHyperscaleDatasetTablesOrFilesRequest) Execute() (*SearchHyperscaleDatasetTablesOrFilesResponse, *http.Response, error) {
	return r.ApiService.SearchHyperscaleDatasetTablesOrFilesExecute(r)
}

/*
SearchHyperscaleDatasetTablesOrFiles Search the tables or files of a hyperscale dataset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleDatasetId The ID of the Hyperscale Dataset.
 @return ApiSearchHyperscaleDatasetTablesOrFilesRequest
*/
func (a *HyperscaleObjectsAPIService) SearchHyperscaleDatasetTablesOrFiles(ctx context.Context, hyperscaleDatasetId string) ApiSearchHyperscaleDatasetTablesOrFilesRequest {
	return ApiSearchHyperscaleDatasetTablesOrFilesRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleDatasetId: hyperscaleDatasetId,
	}
}

// Execute executes the request
//  @return SearchHyperscaleDatasetTablesOrFilesResponse
func (a *HyperscaleObjectsAPIService) SearchHyperscaleDatasetTablesOrFilesExecute(r ApiSearchHyperscaleDatasetTablesOrFilesRequest) (*SearchHyperscaleDatasetTablesOrFilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchHyperscaleDatasetTablesOrFilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.SearchHyperscaleDatasetTablesOrFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-datasets/{hyperscaleDatasetId}/tables-or-files/search"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleDatasetId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleDatasetId, "hyperscaleDatasetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleDatasetId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleDatasetId must have at least 1 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.searchBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchHyperscaleDatasetsRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	limit *int32
	cursor *string
	sort *string
	searchBody *SearchBody
}

// Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100.
func (r ApiSearchHyperscaleDatasetsRequest) Limit(limit int32) ApiSearchHyperscaleDatasetsRequest {
	r.limit = &limit
	return r
}

// Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints.
func (r ApiSearchHyperscaleDatasetsRequest) Cursor(cursor string) ApiSearchHyperscaleDatasetsRequest {
	r.cursor = &cursor
	return r
}

// The field to sort results by. A property name with a prepended &#39;-&#39; signifies descending order.
func (r ApiSearchHyperscaleDatasetsRequest) Sort(sort string) ApiSearchHyperscaleDatasetsRequest {
	r.sort = &sort
	return r
}

// A request body containing a filter expression. This enables searching for items matching arbitrarily complex conditions. The list of attributes which can be used in filter expressions is available in the x-filterable vendor extension.  # Filter Expression Overview **Note: All keywords are case-insensitive**  ## Comparison Operators | Operator | Description | Example | | --- | --- | --- | | CONTAINS | Substring or membership testing for string and list attributes respectively. | field3 CONTAINS &#39;foobar&#39;, field4 CONTAINS TRUE  | | IN | Tests if field is a member of a list literal. List can contain a maximum of 100 values | field2 IN [&#39;Goku&#39;, &#39;Vegeta&#39;] | | GE | Tests if a field is greater than or equal to a literal value | field1 GE 1.2e-2 | | GT | Tests if a field is greater than a literal value | field1 GT 1.2e-2 | | LE | Tests if a field is less than or equal to a literal value | field1 LE 9000 | | LT | Tests if a field is less than a literal value | field1 LT 9.02 | | NE | Tests if a field is not equal to a literal value | field1 NE 42 | | EQ | Tests if a field is equal to a literal value | field1 EQ 42 |  ## Search Operator The SEARCH operator filters for items which have any filterable attribute that contains the input string as a substring, comparison is done case-insensitively. This is not restricted to attributes with string values. Specifically &#x60;SEARCH &#39;12&#39;&#x60; would match an item with an attribute with an integer value of &#x60;123&#x60;.  ## Logical Operators Ordered by precedence. | Operator | Description | Example | | --- | --- | --- | | NOT | Logical NOT (Right associative) | NOT field1 LE 9000 | | AND | Logical AND (Left Associative) | field1 GT 9000 AND field2 EQ &#39;Goku&#39; | | OR | Logical OR (Left Associative) | field1 GT 9000 OR field2 EQ &#39;Goku&#39; |  ## Grouping Parenthesis &#x60;()&#x60; can be used to override operator precedence.  For example: NOT (field1 LT 1234 AND field2 CONTAINS &#39;foo&#39;)  ## Literal Values | Literal      | Description | Examples | | --- | --- | --- | | Nil | Represents the absence of a value | nil, Nil, nIl, NIL | | Boolean | true/false boolean | true, false, True, False, TRUE, FALSE | | Number | Signed integer and floating point numbers. Also supports scientific notation. | 0, 1, -1, 1.2, 0.35, 1.2e-2, -1.2e+2 | | String | Single or double quoted | \&quot;foo\&quot;, \&quot;bar\&quot;, \&quot;foo bar\&quot;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo bar&#39; | | Datetime | Formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) | 2018-04-27T18:39:26.397237+00:00 | | List | Comma-separated literals wrapped in square brackets | [0], [0, 1], [&#39;foo&#39;, \&quot;bar\&quot;] |  ## Limitations - A maximum of 8 unique identifiers may be used inside a filter expression. 
func (r ApiSearchHyperscaleDatasetsRequest) SearchBody(searchBody SearchBody) ApiSearchHyperscaleDatasetsRequest {
	r.searchBody = &searchBody
	return r
}

func (r ApiSearchHyperscaleDatasetsRequest) Execute() (*SearchHyperscaleDatasetsResponse, *http.Response, error) {
	return r.ApiService.SearchHyperscaleDatasetsExecute(r)
}

/*
SearchHyperscaleDatasets Search for Hyperscale Datasets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchHyperscaleDatasetsRequest
*/
func (a *HyperscaleObjectsAPIService) SearchHyperscaleDatasets(ctx context.Context) ApiSearchHyperscaleDatasetsRequest {
	return ApiSearchHyperscaleDatasetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchHyperscaleDatasetsResponse
func (a *HyperscaleObjectsAPIService) SearchHyperscaleDatasetsExecute(r ApiSearchHyperscaleDatasetsRequest) (*SearchHyperscaleDatasetsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchHyperscaleDatasetsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.SearchHyperscaleDatasets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-datasets/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.searchBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchHyperscaleMountPointsRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	limit *int32
	cursor *string
	sort *string
	searchBody *SearchBody
}

// Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100.
func (r ApiSearchHyperscaleMountPointsRequest) Limit(limit int32) ApiSearchHyperscaleMountPointsRequest {
	r.limit = &limit
	return r
}

// Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints.
func (r ApiSearchHyperscaleMountPointsRequest) Cursor(cursor string) ApiSearchHyperscaleMountPointsRequest {
	r.cursor = &cursor
	return r
}

// The field to sort results by. A property name with a prepended &#39;-&#39; signifies descending order.
func (r ApiSearchHyperscaleMountPointsRequest) Sort(sort string) ApiSearchHyperscaleMountPointsRequest {
	r.sort = &sort
	return r
}

// A request body containing a filter expression. This enables searching for items matching arbitrarily complex conditions. The list of attributes which can be used in filter expressions is available in the x-filterable vendor extension.  # Filter Expression Overview **Note: All keywords are case-insensitive**  ## Comparison Operators | Operator | Description | Example | | --- | --- | --- | | CONTAINS | Substring or membership testing for string and list attributes respectively. | field3 CONTAINS &#39;foobar&#39;, field4 CONTAINS TRUE  | | IN | Tests if field is a member of a list literal. List can contain a maximum of 100 values | field2 IN [&#39;Goku&#39;, &#39;Vegeta&#39;] | | GE | Tests if a field is greater than or equal to a literal value | field1 GE 1.2e-2 | | GT | Tests if a field is greater than a literal value | field1 GT 1.2e-2 | | LE | Tests if a field is less than or equal to a literal value | field1 LE 9000 | | LT | Tests if a field is less than a literal value | field1 LT 9.02 | | NE | Tests if a field is not equal to a literal value | field1 NE 42 | | EQ | Tests if a field is equal to a literal value | field1 EQ 42 |  ## Search Operator The SEARCH operator filters for items which have any filterable attribute that contains the input string as a substring, comparison is done case-insensitively. This is not restricted to attributes with string values. Specifically &#x60;SEARCH &#39;12&#39;&#x60; would match an item with an attribute with an integer value of &#x60;123&#x60;.  ## Logical Operators Ordered by precedence. | Operator | Description | Example | | --- | --- | --- | | NOT | Logical NOT (Right associative) | NOT field1 LE 9000 | | AND | Logical AND (Left Associative) | field1 GT 9000 AND field2 EQ &#39;Goku&#39; | | OR | Logical OR (Left Associative) | field1 GT 9000 OR field2 EQ &#39;Goku&#39; |  ## Grouping Parenthesis &#x60;()&#x60; can be used to override operator precedence.  For example: NOT (field1 LT 1234 AND field2 CONTAINS &#39;foo&#39;)  ## Literal Values | Literal      | Description | Examples | | --- | --- | --- | | Nil | Represents the absence of a value | nil, Nil, nIl, NIL | | Boolean | true/false boolean | true, false, True, False, TRUE, FALSE | | Number | Signed integer and floating point numbers. Also supports scientific notation. | 0, 1, -1, 1.2, 0.35, 1.2e-2, -1.2e+2 | | String | Single or double quoted | \&quot;foo\&quot;, \&quot;bar\&quot;, \&quot;foo bar\&quot;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo bar&#39; | | Datetime | Formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) | 2018-04-27T18:39:26.397237+00:00 | | List | Comma-separated literals wrapped in square brackets | [0], [0, 1], [&#39;foo&#39;, \&quot;bar\&quot;] |  ## Limitations - A maximum of 8 unique identifiers may be used inside a filter expression. 
func (r ApiSearchHyperscaleMountPointsRequest) SearchBody(searchBody SearchBody) ApiSearchHyperscaleMountPointsRequest {
	r.searchBody = &searchBody
	return r
}

func (r ApiSearchHyperscaleMountPointsRequest) Execute() (*SearchHyperscaleMountPointsResponse, *http.Response, error) {
	return r.ApiService.SearchHyperscaleMountPointsExecute(r)
}

/*
SearchHyperscaleMountPoints Search for Hyperscale Mount Points.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchHyperscaleMountPointsRequest
*/
func (a *HyperscaleObjectsAPIService) SearchHyperscaleMountPoints(ctx context.Context) ApiSearchHyperscaleMountPointsRequest {
	return ApiSearchHyperscaleMountPointsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchHyperscaleMountPointsResponse
func (a *HyperscaleObjectsAPIService) SearchHyperscaleMountPointsExecute(r ApiSearchHyperscaleMountPointsRequest) (*SearchHyperscaleMountPointsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchHyperscaleMountPointsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.SearchHyperscaleMountPoints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-mount-points/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.searchBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateHyperscaleConnectorByIdRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleConnectorId string
	hyperscaleConnectorUpdateParameters *HyperscaleConnectorUpdateParameters
}

// The new data to update a Hyperscale Connector.
func (r ApiUpdateHyperscaleConnectorByIdRequest) HyperscaleConnectorUpdateParameters(hyperscaleConnectorUpdateParameters HyperscaleConnectorUpdateParameters) ApiUpdateHyperscaleConnectorByIdRequest {
	r.hyperscaleConnectorUpdateParameters = &hyperscaleConnectorUpdateParameters
	return r
}

func (r ApiUpdateHyperscaleConnectorByIdRequest) Execute() (*UpdateHyperscaleConnectorResponse, *http.Response, error) {
	return r.ApiService.UpdateHyperscaleConnectorByIdExecute(r)
}

/*
UpdateHyperscaleConnectorById Update a Hyperscale Connector by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleConnectorId The ID of the Hyperscale Connector.
 @return ApiUpdateHyperscaleConnectorByIdRequest
*/
func (a *HyperscaleObjectsAPIService) UpdateHyperscaleConnectorById(ctx context.Context, hyperscaleConnectorId string) ApiUpdateHyperscaleConnectorByIdRequest {
	return ApiUpdateHyperscaleConnectorByIdRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleConnectorId: hyperscaleConnectorId,
	}
}

// Execute executes the request
//  @return UpdateHyperscaleConnectorResponse
func (a *HyperscaleObjectsAPIService) UpdateHyperscaleConnectorByIdExecute(r ApiUpdateHyperscaleConnectorByIdRequest) (*UpdateHyperscaleConnectorResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateHyperscaleConnectorResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.UpdateHyperscaleConnectorById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-connectors/{hyperscaleConnectorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleConnectorId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleConnectorId, "hyperscaleConnectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleConnectorId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleConnectorId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hyperscaleConnectorUpdateParameters
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateHyperscaleDatasetByIdRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleDatasetId string
	hyperscaleDatasetUpdateParameters *HyperscaleDatasetUpdateParameters
}

// The new data to update a Hyperscale Dataset.
func (r ApiUpdateHyperscaleDatasetByIdRequest) HyperscaleDatasetUpdateParameters(hyperscaleDatasetUpdateParameters HyperscaleDatasetUpdateParameters) ApiUpdateHyperscaleDatasetByIdRequest {
	r.hyperscaleDatasetUpdateParameters = &hyperscaleDatasetUpdateParameters
	return r
}

func (r ApiUpdateHyperscaleDatasetByIdRequest) Execute() (*UpdateHyperscaleDatasetResponse, *http.Response, error) {
	return r.ApiService.UpdateHyperscaleDatasetByIdExecute(r)
}

/*
UpdateHyperscaleDatasetById Update a Hyperscale Dataset by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleDatasetId The ID of the Hyperscale Dataset.
 @return ApiUpdateHyperscaleDatasetByIdRequest
*/
func (a *HyperscaleObjectsAPIService) UpdateHyperscaleDatasetById(ctx context.Context, hyperscaleDatasetId string) ApiUpdateHyperscaleDatasetByIdRequest {
	return ApiUpdateHyperscaleDatasetByIdRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleDatasetId: hyperscaleDatasetId,
	}
}

// Execute executes the request
//  @return UpdateHyperscaleDatasetResponse
func (a *HyperscaleObjectsAPIService) UpdateHyperscaleDatasetByIdExecute(r ApiUpdateHyperscaleDatasetByIdRequest) (*UpdateHyperscaleDatasetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateHyperscaleDatasetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.UpdateHyperscaleDatasetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-datasets/{hyperscaleDatasetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleDatasetId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleDatasetId, "hyperscaleDatasetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleDatasetId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleDatasetId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hyperscaleDatasetUpdateParameters
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateHyperscaleDatasetTableOrFileByIdRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleDatasetId string
	hyperscaleDatasetTableOrFileId string
	hyperscaleDatasetTableOrFileUpdateParameters *HyperscaleDatasetTableOrFileUpdateParameters
}

// The new data to update a Hyperscale Dataset table or file.
func (r ApiUpdateHyperscaleDatasetTableOrFileByIdRequest) HyperscaleDatasetTableOrFileUpdateParameters(hyperscaleDatasetTableOrFileUpdateParameters HyperscaleDatasetTableOrFileUpdateParameters) ApiUpdateHyperscaleDatasetTableOrFileByIdRequest {
	r.hyperscaleDatasetTableOrFileUpdateParameters = &hyperscaleDatasetTableOrFileUpdateParameters
	return r
}

func (r ApiUpdateHyperscaleDatasetTableOrFileByIdRequest) Execute() (*UpdateHyperscaleDatasetTableOrFileResponse, *http.Response, error) {
	return r.ApiService.UpdateHyperscaleDatasetTableOrFileByIdExecute(r)
}

/*
UpdateHyperscaleDatasetTableOrFileById Update a Hyperscale Dataset table or file by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleDatasetId The ID of the Hyperscale Dataset.
 @param hyperscaleDatasetTableOrFileId The ID of the Hyperscale Dataset table or file.
 @return ApiUpdateHyperscaleDatasetTableOrFileByIdRequest
*/
func (a *HyperscaleObjectsAPIService) UpdateHyperscaleDatasetTableOrFileById(ctx context.Context, hyperscaleDatasetId string, hyperscaleDatasetTableOrFileId string) ApiUpdateHyperscaleDatasetTableOrFileByIdRequest {
	return ApiUpdateHyperscaleDatasetTableOrFileByIdRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleDatasetId: hyperscaleDatasetId,
		hyperscaleDatasetTableOrFileId: hyperscaleDatasetTableOrFileId,
	}
}

// Execute executes the request
//  @return UpdateHyperscaleDatasetTableOrFileResponse
func (a *HyperscaleObjectsAPIService) UpdateHyperscaleDatasetTableOrFileByIdExecute(r ApiUpdateHyperscaleDatasetTableOrFileByIdRequest) (*UpdateHyperscaleDatasetTableOrFileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateHyperscaleDatasetTableOrFileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.UpdateHyperscaleDatasetTableOrFileById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-datasets/{hyperscaleDatasetId}/tables-or-files/{hyperscaleDatasetTableOrFileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleDatasetId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleDatasetId, "hyperscaleDatasetId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleDatasetTableOrFileId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleDatasetTableOrFileId, "hyperscaleDatasetTableOrFileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleDatasetId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleDatasetId must have at least 1 elements")
	}
	if strlen(r.hyperscaleDatasetTableOrFileId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleDatasetTableOrFileId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hyperscaleDatasetTableOrFileUpdateParameters
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateHyperscaleMountPointByIdRequest struct {
	ctx context.Context
	ApiService *HyperscaleObjectsAPIService
	hyperscaleMountPointId string
	hyperscaleMountPointUpdateParameters *HyperscaleMountPointUpdateParameters
}

// The new data to update a Hyperscale Mount Point.
func (r ApiUpdateHyperscaleMountPointByIdRequest) HyperscaleMountPointUpdateParameters(hyperscaleMountPointUpdateParameters HyperscaleMountPointUpdateParameters) ApiUpdateHyperscaleMountPointByIdRequest {
	r.hyperscaleMountPointUpdateParameters = &hyperscaleMountPointUpdateParameters
	return r
}

func (r ApiUpdateHyperscaleMountPointByIdRequest) Execute() (*UpdateHyperscaleMountPointResponse, *http.Response, error) {
	return r.ApiService.UpdateHyperscaleMountPointByIdExecute(r)
}

/*
UpdateHyperscaleMountPointById Update a Hyperscale Mount Point by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hyperscaleMountPointId The ID of the Hyperscale Mount Point.
 @return ApiUpdateHyperscaleMountPointByIdRequest
*/
func (a *HyperscaleObjectsAPIService) UpdateHyperscaleMountPointById(ctx context.Context, hyperscaleMountPointId string) ApiUpdateHyperscaleMountPointByIdRequest {
	return ApiUpdateHyperscaleMountPointByIdRequest{
		ApiService: a,
		ctx: ctx,
		hyperscaleMountPointId: hyperscaleMountPointId,
	}
}

// Execute executes the request
//  @return UpdateHyperscaleMountPointResponse
func (a *HyperscaleObjectsAPIService) UpdateHyperscaleMountPointByIdExecute(r ApiUpdateHyperscaleMountPointByIdRequest) (*UpdateHyperscaleMountPointResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateHyperscaleMountPointResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HyperscaleObjectsAPIService.UpdateHyperscaleMountPointById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hyperscale-mount-points/{hyperscaleMountPointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hyperscaleMountPointId"+"}", url.PathEscape(parameterValueToString(r.hyperscaleMountPointId, "hyperscaleMountPointId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hyperscaleMountPointId) < 1 {
		return localVarReturnValue, nil, reportError("hyperscaleMountPointId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hyperscaleMountPointUpdateParameters
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
