/*
Delphix DCT API

Delphix DCT API

API version: 3.18.0
Contact: support@delphix.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package delphix_dct_api

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the LoginToken type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &LoginToken{}

// LoginToken struct for LoginToken
type LoginToken struct {
	// Opaque token that validates the successful account login and is used to authenticate subsequent api calls. This token needs to be sent as part of 'Authorization' header for all api calls prefixed with value contained in 'token_type' property. For example, if the 'access_token' value is \"abc123\" and 'token_type' is \"Bearer\" then HTTP requests should contain following header : \"Authorization: Bearer abc123\" 
	AccessToken string `json:"access_token"`
	// Type of the token returned in 'access_token' property.
	TokenType string `json:"token_type"`
	// Seconds duration after which the token will expire.
	ExpiresIn int64 `json:"expires_in"`
}

type _LoginToken LoginToken

// NewLoginToken instantiates a new LoginToken object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewLoginToken(accessToken string, tokenType string, expiresIn int64) *LoginToken {
	this := LoginToken{}
	this.AccessToken = accessToken
	this.TokenType = tokenType
	this.ExpiresIn = expiresIn
	return &this
}

// NewLoginTokenWithDefaults instantiates a new LoginToken object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewLoginTokenWithDefaults() *LoginToken {
	this := LoginToken{}
	return &this
}

// GetAccessToken returns the AccessToken field value
func (o *LoginToken) GetAccessToken() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.AccessToken
}

// GetAccessTokenOk returns a tuple with the AccessToken field value
// and a boolean to check if the value has been set.
func (o *LoginToken) GetAccessTokenOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.AccessToken, true
}

// SetAccessToken sets field value
func (o *LoginToken) SetAccessToken(v string) {
	o.AccessToken = v
}

// GetTokenType returns the TokenType field value
func (o *LoginToken) GetTokenType() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.TokenType
}

// GetTokenTypeOk returns a tuple with the TokenType field value
// and a boolean to check if the value has been set.
func (o *LoginToken) GetTokenTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.TokenType, true
}

// SetTokenType sets field value
func (o *LoginToken) SetTokenType(v string) {
	o.TokenType = v
}

// GetExpiresIn returns the ExpiresIn field value
func (o *LoginToken) GetExpiresIn() int64 {
	if o == nil {
		var ret int64
		return ret
	}

	return o.ExpiresIn
}

// GetExpiresInOk returns a tuple with the ExpiresIn field value
// and a boolean to check if the value has been set.
func (o *LoginToken) GetExpiresInOk() (*int64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ExpiresIn, true
}

// SetExpiresIn sets field value
func (o *LoginToken) SetExpiresIn(v int64) {
	o.ExpiresIn = v
}

func (o LoginToken) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o LoginToken) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["access_token"] = o.AccessToken
	toSerialize["token_type"] = o.TokenType
	toSerialize["expires_in"] = o.ExpiresIn
	return toSerialize, nil
}

func (o *LoginToken) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"access_token",
		"token_type",
		"expires_in",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varLoginToken := _LoginToken{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varLoginToken)

	if err != nil {
		return err
	}

	*o = LoginToken(varLoginToken)

	return err
}

type NullableLoginToken struct {
	value *LoginToken
	isSet bool
}

func (v NullableLoginToken) Get() *LoginToken {
	return v.value
}

func (v *NullableLoginToken) Set(val *LoginToken) {
	v.value = val
	v.isSet = true
}

func (v NullableLoginToken) IsSet() bool {
	return v.isSet
}

func (v *NullableLoginToken) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableLoginToken(val *LoginToken) *NullableLoginToken {
	return &NullableLoginToken{value: val, isSet: true}
}

func (v NullableLoginToken) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableLoginToken) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


